
// Define the conversational SOuLO prompt for journal-specific queries
const JOURNAL_SPECIFIC_PROMPT = `You are SOULo, an AI mental health therapist assistant that helps users understand their journal entries and emotional patterns through evidence-based therapeutic analysis.

THERAPEUTIC IDENTITY & APPROACH: You are trained in multiple therapeutic modalities including Cognitive Behavioral Therapy (CBT), Dialectical Behavior Therapy (DBT), and mindfulness-based approaches.

Journal excerpts:
{journalData}
(Spanning from {startDate} to {endDate})

User's question: "{userMessage}"

CRITICAL EMOTION ANALYSIS INSTRUCTIONS:
• You have access to PRE-CALCULATED emotion scores from the database (0.0 to 1.0 scale)
• These scores were generated by advanced AI analysis of the journal content
• DO NOT attempt to infer emotions from the text snippets - use ONLY the provided scores
• Focus on quantitative therapeutic analysis: emotional patterns, regulation strategies, score distributions
• When you see "Score: 0.842" this means that emotion was detected with 84.2% intensity
• NEVER say "your entries don't explicitly mention emotions" - the emotions are already calculated

STRUCTURED RESPONSE FORMAT:
Use this structured format for all journal-based responses:

**## [Main Insight/Pattern Title]**

**What I Found in Your Entries:**
- [Key pattern or insight from journal data]
- [Specific dates/timeframes when relevant]
- [Emotion scores or themes that stand out]

**Understanding Your Journey:**
> "[Brief meaningful quote from their entries when relevant]"
- [Analysis of what this reveals]
- [Connection to broader patterns]

**Therapeutic Insights:**
- [CBT/DBT/mindfulness perspective on the patterns]
- [Growth opportunities identified]
- [Emotional regulation observations]

**Reflection Questions:**
- [Thoughtful question to deepen self-awareness]
- [Question connecting past patterns to future growth]

FORMATTING RULES:
- Use **bold** for all headers (## for main header, ** for sub-headers)
- Use bullet points (-) for insights and observations
- Use > blockquotes for journal entry excerpts
- Keep paragraphs concise (2-3 sentences max)
- Reference specific dates and emotional scores when relevant
- Provide actionable, personalized recommendations
- Maintain professional therapeutic boundaries while being approachable
- Only use facts from journal entries — no assumptions, no hallucinations
- Back insights with specific examples when relevant

QUOTE INTEGRATION:
- Only include direct quotes when they meaningfully support your analysis
- Keep quotes brief (1-2 sentences max)
- Ensure quotes are actual excerpts from their entries
- Use quotes to illustrate patterns or insights

Remember: You're a supportive AI therapist, not a medical report generator. Be warm, insightful, and genuinely helpful while maintaining the structured format.`;

// Define the general question prompt with conversational approach
const GENERAL_QUESTION_PROMPT = `You are SOULo, an AI mental health therapist assistant trained in CBT, DBT, and mindfulness. You are part of a voice journaling app called "SOULo".

For general mental health questions that don't specifically mention the user's personal journal entries, provide helpful guidance in a conversational, supportive manner. For personalized insights, suggest that you could analyze their journal entries if they'd like.

STRUCTURED RESPONSE FORMAT:
Use this structured format for general mental health responses:

**## [Main Topic/Theme]**

**Understanding Your Situation:**
- [Acknowledgment of their concern/question]
- [Validation of their experience]

**Key Insights:**
- [Primary insight or understanding]
- [Secondary insight if relevant]
- [Connection to therapeutic principles]

**Practical Steps:**
- [Actionable suggestion 1]
- [Actionable suggestion 2]
- [Mindfulness or coping technique]

**Moving Forward:**
- [Encouragement or next steps]
- [Invitation for further exploration]

RESPONSE GUIDELINES:
- Be conversational and supportive, like a caring counselor
- Use natural, therapeutic language within the structured format
- Keep responses concise and actionable
- If the question is unrelated to mental health or journaling, politely redirect to the app's purpose
- Provide evidence-based guidance while maintaining warmth`;

/**
 * Generate a response using the entries and user message
 */
export async function generateResponse(
  entries: any[],
  message: string,
  conversationContext: any[],
  apiKey: string
): Promise<string> {
  try {
    // Get earliest and latest entry dates
    let earliestDate = null;
    let latestDate = null;
    
    // Format entries for the prompt with dates and emotion scores
    const entriesWithDates = entries.map(entry => {
      const entryDate = new Date(entry.created_at);
      
      // Track earliest and latest dates
      if (!earliestDate || entryDate < earliestDate) {
        earliestDate = entryDate;
      }
      if (!latestDate || entryDate > latestDate) {
        latestDate = entryDate;
      }
      
      const formattedDate = entryDate.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
      
      // Format emotion scores if they exist
      let emotionInfo = '';
      if (entry.emotions && typeof entry.emotions === 'object') {
        const emotions = Object.entries(entry.emotions)
          .filter(([_, score]) => typeof score === 'number' && score > 0.3)
          .sort(([_, a], [__, b]) => (b as number) - (a as number))
          .slice(0, 3)
          .map(([emotion, score]) => `${emotion}: ${(score as number).toFixed(2)}`)
          .join(', ');
        
        if (emotions) {
          emotionInfo = `\nEmotion scores: ${emotions}`;
        }
      }
      
      // Format themes info
      let themeInfo = '';
      if (entry.master_themes && Array.isArray(entry.master_themes)) {
        themeInfo = `\nThemes: ${entry.master_themes.join(', ')}`;
      }

      // Format sentiment info with score
      const sentimentInfo = entry.sentiment 
        ? `\nSentiment score: ${entry.sentiment.toFixed(2)} (${
            entry.sentiment <= -0.2 ? 'negative' :
            entry.sentiment >= 0.2 ? 'positive' : 'neutral'
          })`
        : '';

      return `- Entry from ${formattedDate}: ${entry.content}${emotionInfo}${themeInfo}${sentimentInfo}`;
    }).join('\n\n');
    
    // Format date range for the prompt
    const startDateFormatted = earliestDate ? earliestDate.toLocaleDateString('en-US', {
      month: 'long',
      day: 'numeric',
      year: 'numeric'
    }) : 'unknown date';
    
    const endDateFormatted = latestDate ? latestDate.toLocaleDateString('en-US', {
      month: 'long',
      day: 'numeric',
      year: 'numeric'
    }) : 'unknown date';

    // Prepare prompt with updated SOuLO format
    const promptFormatted = JOURNAL_SPECIFIC_PROMPT
      .replace('{journalData}', entriesWithDates)
      .replace('{userMessage}', message)
      .replace('{startDate}', startDateFormatted)
      .replace('{endDate}', endDateFormatted);
      
    // Call OpenAI with structured SOuLO prompt
    console.log("Calling OpenAI with structured SOuLO prompt format");
    
    // Prepare the messages array with system prompt and conversation context
    const messages = [];
    
    // Add system prompt
    messages.push({ role: 'system', content: promptFormatted });
    
    // Add conversation context if available
    if (conversationContext.length > 0) {
      console.log(`Including ${conversationContext.length} messages of conversation context`);
      messages.push(...conversationContext);
      messages.push({ role: 'user', content: message });
    }
    
    const completionResponse = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: conversationContext.length > 0 ? messages : [{ role: 'system', content: promptFormatted }],
        max_tokens: 800, // Increased to accommodate structured format
        temperature: 0.7,
      }),
    });

    if (!completionResponse.ok) {
      const error = await completionResponse.text();
      console.error('Failed to get completion:', error);
      throw new Error('Failed to generate response');
    }

    const completionData = await completionResponse.json();
    const responseContent = completionData.choices[0]?.message?.content || 'Sorry, I could not generate a response.';
    
    return responseContent;
  } catch (error) {
    console.error('Error generating response:', error);
    throw error;
  }
}

// Function to check for potentially hallucinated dates in the response
export function checkForHallucinatedDates(response: string, entries: any[]): boolean {
  try {
    // Extract all potential dates from the response using regex
    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    const monthRegex = new RegExp(`\\b(${months.join('|')})\\s+\\d{1,2}(?:st|nd|rd|th)?(?:\\s*,?\\s*\\d{4})?\\b`, 'gi');
    const foundDates = response.match(monthRegex) || [];
    
    // Create a set of actual dates from entries
    const actualDates = new Set();
    entries.forEach(entry => {
      const date = new Date(entry.created_at);
      months.forEach(month => {
        // Add various formats of the same date
        const monthName = date.toLocaleDateString('en-US', { month: 'long' });
        const day = date.getDate();
        const year = date.getFullYear();
        
        actualDates.add(`${monthName} ${day}`);
        actualDates.add(`${monthName} ${day}, ${year}`);
        actualDates.add(`${monthName} ${day}th`);
        actualDates.add(`${monthName} ${day}st`);
        actualDates.add(`${monthName} ${day}nd`);
        actualDates.add(`${monthName} ${day}rd`);
      });
    });
    
    // Check if any found dates are not in the actual dates set
    for (const foundDate of foundDates) {
      // Normalize the found date for comparison
      const normalizedDate = foundDate.replace(/(?:st|nd|rd|th)/, '').replace(/\s+/g, ' ').trim();
      
      // Extract just month and day for partial matching
      const parts = normalizedDate.split(' ');
      if (parts.length >= 2) {
        const monthDay = `${parts[0]} ${parts[1].replace(',', '')}`;
        
        // Check if either the full date or the month+day exists in actual dates
        if (!actualDates.has(normalizedDate) && !actualDates.has(monthDay)) {
          console.warn(`Potential hallucinated date found: ${foundDate}`);
          return true;
        }
      }
    }
    
    return false;
  } catch (error) {
    console.error("Error checking for hallucinated dates:", error);
    return false; // Default to not blocking the response
  }
}
