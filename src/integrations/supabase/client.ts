// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://kwnwhgucnzqxndzjayyq.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt3bndoZ3VjbnpxeG5kempheXlxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIzMzk4ODMsImV4cCI6MjA1NzkxNTg4M30.UAB3e5b44iJa9kKT391xyJKoQmlUOtsAi-yp4UEqZrc";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  global: {
    fetch: (url, options) => {
      const fetchOptions = options || {};
      const headers = new Headers(fetchOptions.headers);
      
      // Add client version for feature detection
      headers.set('x-client-version', '1.1.0');
      headers.set('x-chunking-enabled', 'true');
      
      // Add request timeout with improved error handling
      const timeoutController = new AbortController();
      const timeoutId = setTimeout(() => {
        console.log(`Fetch timeout triggered for: ${url.toString()}`);
        timeoutController.abort();
      }, 20000); // Increase to 20 second timeout
      
      // Create a signal that works with both the timeout and any existing signal
      let finalSignal = timeoutController.signal;
      if (fetchOptions.signal) {
        // This combines the timeout signal with any existing signal
        const existingSignal = fetchOptions.signal;
        
        // Create a composite abort controller
        const compositeController = new AbortController();
        finalSignal = compositeController.signal;
        
        // Watch both signals
        const abortHandler = () => {
          console.log(`Existing abort signal triggered for: ${url.toString()}`);
          timeoutController.abort();
          clearTimeout(timeoutId);
        };
        
        const timeoutHandler = () => {
          console.log(`Timeout abort signal triggered for: ${url.toString()}`);
          compositeController.abort();
          clearTimeout(timeoutId);
        };
        
        existingSignal.addEventListener('abort', abortHandler);
        timeoutController.signal.addEventListener('abort', timeoutHandler);
      }
      
      console.log(`Fetch request to: ${url.toString()}`);
      
      // Add error handling for the fetch itself
      return fetch(url, { 
        ...fetchOptions,
        headers,
        signal: finalSignal 
      })
      .then(response => {
        clearTimeout(timeoutId);
        return response;
      })
      .catch(error => {
        clearTimeout(timeoutId);
        console.error(`Fetch error for ${url.toString()}:`, error);
        throw error; // Re-throw to be handled by the caller
      });
    }
  }
});

// Export these constants for direct use in other files
export { SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY };

// Helper function to check if chunking is supported on the server
export async function isChunkingSupported(): Promise<boolean> {
  try {
    // First, try to verify edge function availability with better error handling
    let edgeFunctionsAvailable = false;
    try {
      const healthStatus = await checkEdgeFunctionsHealth();
      edgeFunctionsAvailable = Object.values(healthStatus).some(status => status === true);
      console.log('Edge functions health check result:', healthStatus);
    } catch (healthError) {
      console.warn('Edge functions health check failed completely:', healthError);
      // Continue despite health check failure - try the DB check
    }
    
    // Check if the journal_chunks table exists by making a direct query
    const { data, error } = await supabase
      .from('journal_chunks')
      .select('id')
      .limit(1);
    
    if (error) {
      console.error('Error checking if chunking is supported:', error);
      return false;
    }
    
    // Either the edge functions are available or the table exists
    return edgeFunctionsAvailable || (data && data.length >= 0);
  } catch (error) {
    console.error('Exception checking if chunking is supported:', error);
    return false;
  }
}

// Add a helper function to check the health of all edge functions
export async function checkEdgeFunctionsHealth(): Promise<Record<string, boolean>> {
  const functionsToCheck = ['process-journal', 'chunk-and-embed', 'chat-with-rag', 'chat-rag'];
  const results: Record<string, boolean> = {};
  
  const checkPromises = functionsToCheck.map(async (func) => {
    try {
      // Create a controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      try {
        console.log(`Checking health of edge function: ${func}`);
        const response = await fetch(`${SUPABASE_URL}/functions/v1/${func}/health`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
            'Content-Type': 'application/json'
          },
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
          try {
            const data = await response.json();
            results[func] = data?.status === 'healthy';
            console.log(`Health check for ${func}: ${results[func] ? 'healthy' : 'unhealthy'}`);
          } catch (jsonError) {
            console.warn(`Health check for ${func} returned non-JSON response:`, await response.text());
            results[func] = false;
          }
        } else {
          console.warn(`Health check for ${func} failed with status:`, response.status);
          results[func] = false;
        }
      } catch (fetchError) {
        clearTimeout(timeoutId);
        console.error(`Fetch error in health check for ${func}:`, fetchError);
        results[func] = false;
      }
    } catch (error) {
      console.error(`Health check failed for ${func}:`, error);
      results[func] = false;
    }
  });
  
  await Promise.allSettled(checkPromises);
  return results;
}
